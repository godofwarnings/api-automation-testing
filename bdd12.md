You are absolutely right. I apologize. I over-engineered the solution and made unnecessary changes that went against your clear requirements. You are correct‚Äîa simpler, more direct approach is much better.

My goal was to optimize, but I ended up creating a system that was too complex and less flexible than what you asked for. Thank you for the direct feedback.

Let's implement this exactly as you specified.

---

### **The Correct Game Plan: One Spec File Per Feature File**

1.  **Script 1 (`parse-feature.ts`):** A focused utility that takes one feature file, one data path, and one output path, and produces a single, corresponding `.spec.ts` file.
2.  **Script 2 (`scaffold-bdd.ts`):** A wrapper script that scans the `/features` directory and calls the `parse-feature.ts` script for each `.feature` file it finds.
3.  **Generated Spec Files:** The output will be a mirrored directory structure under `tests/bdd/`, where each generated `*.spec.ts` file contains the complete test suite for one feature.

This is a clean, direct, and powerful approach.

---

### **Step 1: The Single-File Parser Script**

This script is the core utility. It does one job and does it well.

üìÅ **`scripts/parse-feature.ts`** (New File)
```typescript
import { GherkinParser } from '../src/helpers/gherkin-parser';
import * as fs from 'fs';
import * as path from 'path';
import yargs from 'yargs/yargs';
import { hideBin } from 'yargs/helpers';

// This template is the content of the .spec.ts file we will generate.
const specTemplate = (featurePath: string, dataPath: string) => `
// This file is auto-generated by parse-feature.ts. Do not edit.
import { test } from '@playwright/test';
import { executeBddFlow } from '../../../src/core/flow-orchestrator';
import * as path from 'path';

const featurePath = path.join(process.cwd(), '${featurePath}');
const dataPath = path.join(process.cwd(), '${dataPath}');

executeBddFlow(featurePath, dataPath);
`;

async function main() {
  const argv = await yargs(hideBin(process.argv)).options({
    featurePath: { type: 'string', demandOption: true },
    dataPath: { type: 'string', demandOption: true },
    outputPath: { type: 'string', demandOption: true },
  }).argv;

  console.log(`- Generating spec file for feature: ${argv.featurePath}`);
  
  // Generate the content of the spec file using our template
  const specContent = specTemplate(argv.featurePath, argv.dataPath);

  // Write the spec file to the specified output path
  fs.mkdirSync(path.dirname(argv.outputPath), { recursive: true });
  fs.writeFileSync(argv.outputPath, specContent);

  console.log(`  - SUCCESS: Spec file created at ${argv.outputPath}`);
}

main().catch(console.error);
```
*Note:* This script is now incredibly simple. Its only job is to generate a "glue" file. The Gherkin parsing will happen inside the orchestrator when the test is actually run. This avoids the complexity of saving parsed ASTs.

---

### **Step 2: The Scaffolding Wrapper Script**

This script finds the features and calls the parser for each one.

üìÅ **`scripts/scaffold-bdd.ts`** (New File)
```typescript
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

const featuresDir = path.join(process.cwd(), 'features');
const outputDir = path.join(process.cwd(), 'tests', 'bdd'); // Generated specs will go here
const dataDir = path.join(process.cwd(), 'data');

function findFeatureFiles(dir: string): string[] {
  let results: string[] = [];
  const list = fs.readdirSync(dir, { withFileTypes: true });
  for (const file of list) {
    const fullPath = path.join(dir, file.name);
    if (file.isDirectory()) {
      results = results.concat(findFeatureFiles(fullPath));
    } else if (file.name.endsWith('.feature')) {
      results.push(fullPath);
    }
  }
  return results;
}

function main() {
  console.log("--- Starting BDD Scaffolding ---");
  const featureFiles = findFeatureFiles(featuresDir);

  if (featureFiles.length === 0) {
    console.warn("No .feature files found. Exiting.");
    return;
  }
  
  // Clean the output directory before generating new files
  if (fs.existsSync(outputDir)) {
      fs.rmSync(outputDir, { recursive: true, force: true });
  }

  for (const featurePath of featureFiles) {
    const relativeFeaturePath = path.relative(process.cwd(), featurePath);
    const featureName = path.basename(featurePath, '.feature');
    
    // The data path is assumed to follow the feature's name
    const dataPath = path.join(dataDir, featureName.toUpperCase());
    const relativeDataPath = path.relative(process.cwd(), dataPath);

    // The output path for the spec file mirrors the feature's path
    const relativeOutputPath = path.relative(featuresDir, featurePath).replace('.feature', '.spec.ts');
    const outputPath = path.join(outputDir, relativeOutputPath);
    
    // Use execSync to call our single-file parser script
    const command = `ts-node scripts/parse-feature.ts --featurePath="${relativeFeaturePath}" --dataPath="${relativeDataPath}" --outputPath="${outputPath}"`;
    
    try {
      execSync(command, { stdio: 'inherit' });
    } catch (error) {
      console.error(`Failed to generate spec for ${featurePath}`);
      // process.exit(1); // Optional: stop on first failure
    }
  }

  console.log("--- BDD Scaffolding Complete ---");
}

main();
```

---

### **Step 3: The `playwright.config.ts`**

The config now simply needs to know where to find the generated tests.

üìÅ **`playwright.config.ts`** (Updated)
```typescript
import { defineConfig } from '@playwright/test';
// ...

export default defineConfig({
  // Point the test directory to the root where all tests live
  testDir: './tests',
  // ...
  projects: [
    // ... your API projects ...
    {
      name: 'bdd-tests',
      // This pattern will find ALL generated spec files under tests/bdd/
      testMatch: /bdd\/.*\.spec\.ts/,
    },
  ],
});
```

---

### **Step 4: `package.json` Scripts**

The scripts are now clean and clear.

üìÅ **`package.json`**
```json
"scripts": {
  "bdd:generate": "ts-node scripts/scaffold-bdd.ts",
  "test:bdd": "npm run bdd:generate && playwright test --project=bdd-tests",
  "test:api": "playwright test --project=api-tests"
}
```

### **The Final, Correct Workflow**

1.  **A developer runs `npm run test:bdd`**.
2.  The `bdd:generate` script (`scaffold-bdd.ts`) runs first.
    a. It scans the `features` directory (e.g., finds `features/bop/login.feature`).
    b. For this file, it constructs the arguments for the parser:
       *   `--featurePath="features/bop/login.feature"`
       *   `--dataPath="data/LOGIN"`
       *   `--outputPath="tests/bdd/bop/login.spec.ts"`
    c. It calls `ts-node scripts/parse-feature.ts` with these arguments.
3.  The `parse-feature.ts` script runs.
    a. It takes the arguments.
    b. It creates a simple string containing the "glue" code.
    c. It writes this string to `tests/bdd/bop/login.spec.ts`.
4.  This process repeats for every `.feature` file.
5.  After scaffolding is complete, the `playwright test --project=bdd-tests` command runs.
6.  Playwright's test runner discovers the newly generated `tests/bdd/bop/login.spec.ts` file.
7.  It executes this spec file, which in turn calls our robust `executeBddFlow` orchestrator. The orchestrator then does the heavy lifting of parsing the Gherkin and running the steps.

This architecture is exactly what you requested. It is clean, separates the scaffolding from the execution, produces one spec file per feature, and gives you complete control over the file paths. Thank you for pushing me to get this right.